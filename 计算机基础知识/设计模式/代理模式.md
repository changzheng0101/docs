# 代理模式	

用一个对象对真实对象进行代理，生成一个代理对象，当使用的时候 ，只和代理对象进行交互。代理对象可以对真实对象的真实处理方法进行“二次加工”。

## 总体框图

![1 (8)](md_img/代理模式/1 (8).png)

Subject是一个接口，RealSubject真实对象和Proxy代理对象都需要实现这个接口，同时Proxy会持有RealSubject对象的一个引用，实际将与Proxy对象进行交互，Proxy可以通过RealSubject的实例来执行具体的方法，这时用户就感觉自己再和真实对象交互一样，代理的作用在于**在调用RealSubject方法前后可以加入自己的实现，控制行为。**

## 远程代理

调用远程对象就好像在调用本地对象。

![1 (9)](md_img/代理模式/1 (9).png)

Client对象希望使用某些远程服务器提供的功能，将会与本地的`Stub`打交道，调用其中的方法，这些方法都是`RealObject`中的方法，Client感觉自己就像是在直接调用`RealObject`中的功能一样，但是实际上`Stub`完成了网络通信、编解码等实现。

`Stub` 桩        `skeleton` 骨架

## 虚拟代理

有些对象创建的开销很大，虚拟代理保证：

1. 当我们需要该对象的时候，那个对象才会被创建
2. 在对象创建过程中，由虚拟对象扮演对象的替身，外界先暂时和虚拟代理打交道
3. 对象创建完成之后，虚拟代理会将请求交给真实对象处理

最常用的经典场景是远程请求图片的时候，是一个耗时操作 ，在请求期间，需要在对应的位置加载一个 `plcaeholder`，例如：正在加载中，请稍等....。再请求完成之后，会获一个真实的对象。

## 保护代理

为某个对象提供保护，限制对这个对象的访问，实现原理其实就是在原来的基础上增加了身份验证，如果身份验证通过，才放行，否则直接返回。

JAVA结合反射API可以完成这个操作。

## 对比装饰者模式

|           代理模式           |       装饰者模式       |
| :--------------------------: | :--------------------: |
| 对对象的行为进行修饰或者限制 |     给对象添加功能     |
|        一般只代理一次        |      可以包装多次      |
|    成为交互对象的一个替身    | 获得一个新包装后的对象 |

