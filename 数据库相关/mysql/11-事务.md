# 事务 transactions

事务其实就是一堆SQL代码，这堆代码要么全部执行，要么全部不执行。

## 事务的特性

### 原子性

要么全成功，要么全失败，如果只执行了部分代码，会进行回滚的操作。

## 一致性

保证数据一致，不会只更新某一部分数据。

### 隔离性

一行同时只能有一个事务操作，事务会锁定对应的行。

### 持久性

事务产生的改变是永久的

## 创建事务

```sql
START TRANSACTION

INSERT INTO orders(customer_id,order_date,STATUS)
VALUES (1,'2019-01-01',1);

INSERT INTO order_items 
VALUES (LAST_INSERT_ID(),1,1,1);

COMMIT;
```

## 并发

>当多个事务同时访问某一行数据的时候，先访问的事务会对这行数据进行加锁，**当该事务完成之后，别的事务才可以访问这行数据，**其他事务无法访问。

### 丢失更新

同时对某行数据进行更新，后更新的数据会作为最终的结果，先更新的操作对应的更新会丢失。

### 脏读:red_car:

更新了某行的数据，还未提交，另一个用户读取了数据，但是之后对某行的更新进行了回滚，另一个用户读取到了根本不存在的数据。

所以要让数据更新之后不能直接就可以被其他用户读取，必须事务提交之后才可以被其他用户读取。

### 不可重复读:no_bell:

事务A读取point为10，事务B更新point为20，当事务A再次读取point时，会读取到20，两次读取的结果不一致。

保证事务A在执行过程中读取到的数据一致，需要让A读取的都是保存的快照。

### 幻读

事务A读取point大于10的数据，事务B更新了某条数据，



### 解决并发

上述提到的四种问题，可以通过设置`ISOLATION LEVEL`来进行避免。

查看目前的`ISOLATION LEVEL`

```sql
show variables like 'transaction_isolation';
```



## 死锁:deciduous_tree:

|  事务一   |  事务二   |
| :-------: | :-------: |
| 更新第3行 | 更新第5行 |
| 更新第5行 | 更新第3行 |

当事务一更新完第3行之后，会对第3行上锁，事务二此时更新第5行，对第5行上锁，第3行和第5行都被上锁，程序无法继续执行，造成死锁。

